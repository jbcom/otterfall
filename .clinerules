

<!-- Source: AGENTS.md -->

# Rivermarsh Game Development - Executive Summary

**Status:** Active development with AI-first workflow  
**Target Platform:** Web (mobile-optimized, 60fps)  
**Architecture:** React + Three.js + ECS + AI agents

## Quick Navigation

- **Client Development:** See `client/.ruler/`
- **Python Tooling:** See `python/.ruler/`
- **CrewAI Workflows:** See `python/crew_agents/.ruler/`
- **Documentation Standards:** See `docs/.ruler/`
- **Shared Contracts:** See `shared/contracts/README.md`

## Core Principles

1. **Nested Ruler Structure** - Each component has its own `.ruler/` directory
2. **AI-Agent Collaboration** - CrewAI handles backend, human handles frontend
3. **Mobile-First Performance** - 60fps on mid-tier phones
4. **Type Safety** - Zero TypeScript errors enforced
5. **ECS Architecture** - Miniplex for world simulation

## Technology Stack

**Frontend:** React 18, TypeScript (strict), React Three Fiber, Zustand, Miniplex  
**AI:** Yuka.js for creature behaviors  
**Automation:** CrewAI with OpenRouter, MCP servers  
**Build:** Vite 7, pnpm, Node 24, Python 3.13  

## Current Sprint

Building autonomous CrewAI development crew to accelerate:
- ECS component schemas
- Daggerfall Unity data parsing
- Yuka AI integration
- Procedural terrain/water rendering
- Quest/dialogue systems

**See `python/crew_agents/.ruler/workflow_configuration.md` for agent hierarchy.**

## Development Workflow

1. Define contracts in `shared/contracts/`
2. CrewAI agents build backend systems in `shared/backend/`
3. Human reviews and integrates with frontend prototypes
4. Iterate based on testing feedback

**See `docs/.ruler/parallel_development.md` for detailed workflow.**



<!-- Source: .ruler/AGENTS.md -->

# Cross-Cutting Technical Standards

These rules apply across all components of the Rivermarsh project.

## TypeScript Standards

### Strict Mode Requirements
```typescript
// tsconfig.json must have:
"strict": true,
"noUncheckedIndexedAccess": true,
"noImplicitReturns": true
```

### No `any` Types
```typescript
// ❌ Bad
function processData(data: any) { }

// ✅ Good
function processData<T extends Record<string, unknown>>(data: T) { }
```

### Type Exports
Every module must export its public types:
```typescript
export type { Entity, Component, System };
```

## State Management

### Zustand Store Pattern
```typescript
import { create } from 'zustand';

export const useStore = create<State>((set, get) => ({
  // State
  value: 0,

  // Actions
  increment: () => set(state => ({ value: state.value + 1 })),
}));
```

### ECS Component Queries
```typescript
// Use Miniplex queries, not manual filtering
const movingEntities = world.with('transform', 'velocity');
```

## Performance Standards

### Mobile Budget (60 FPS target)
- **Draw Calls**: < 100 per frame
- **Vertices**: < 500k per frame
- **Texture Memory**: < 200MB total
- **Shader Instructions**: < 200 per pixel

### Profiling Required
Before optimizing, measure with:
```typescript
import { Perf } from 'r3f-perf';
// Add <Perf /> to scene during development
```

## Error Handling

### Always Handle Async Errors
```typescript
// ❌ Bad
async function loadAsset() {
  const data = await fetch(url);
}

// ✅ Good
async function loadAsset(): Promise<Result<Asset, Error>> {
  try {
    const data = await fetch(url);
    return { ok: true, value: data };
  } catch (error) {
    return { ok: false, error };
  }
}
```

## File Organization

### Import Order
1. External dependencies
2. Internal absolute imports (`@/...`)
3. Relative imports (`./`, `../`)
4. Type imports (at end with `import type`)

```typescript
import React from 'react';
import { Canvas } from '@react-three/fiber';
import { useGame } from '@/lib/stores/useGame';
import { Player } from './Player';
import type { Entity } from '@/ecs/world';



<!-- Source: .ruler/ecs_patterns.md -->

# ECS (Entity Component System) Patterns with Miniplex

## Core Philosophy

- **Entities** = Unique IDs with component bags
- **Components** = Pure data (no methods)
- **Systems** = Logic that operates on component queries

## Component Definition

```typescript
// Good - Pure data, explicit types
export interface TransformComponent {
  position: Vector3;
  rotation: Quaternion;
  scale: Vector3;
}

export interface HealthComponent {
  current: number;
  max: number;
  invulnerable: boolean;
}

// Bad - Methods in components
export interface BadComponent {
  value: number;
  update(): void; // ❌ No methods!
}
```

## World Creation

```typescript
import { World } from 'miniplex';

export type Entity = {
  // Core components
  transform?: TransformComponent;
  mesh?: MeshComponent;
  
  // Gameplay components
  health?: HealthComponent;
  ai?: AIComponent;
  inventory?: InventoryComponent;
  
  // Metadata
  tags?: Set<string>;
  name?: string;
};

export const world = new World<Entity>();
```

## Entity Creation Patterns

```typescript
// Factory pattern for consistent creation
export function createOtter(position: Vector3): Entity {
  return world.add({
    name: 'Otter',
    tags: new Set(['player', 'creature']),
    transform: {
      position,
      rotation: new Quaternion(),
      scale: new Vector3(1, 1, 1),
    },
    health: {
      current: 100,
      max: 100,
      invulnerable: false,
    },
    mesh: {
      ref: null, // Will be set by rendering system
    },
  });
}
```

## Querying Entities

```typescript
// With required components
const movableEntities = world.with('transform', 'velocity');

// With excluded components
const livingEnemies = world
  .with('health', 'ai')
  .without('dead');

// Iteration
for (const entity of movableEntities) {
  entity.transform.position.add(entity.velocity);
}
```

## Archetype Pattern (Performance)

```typescript
// Pre-create archetypes for fast queries
const trees = world.archetype('transform', 'mesh', 'tree');
const enemies = world.archetype('transform', 'health', 'ai', 'enemy');

// Fast iteration (cache-friendly)
for (const enemy of enemies) {
  // All components guaranteed to exist
  updateAI(enemy.ai, enemy.transform);
}
```

## React Integration

```typescript
import { useEntities } from 'miniplex-react';

function PlayerHealthUI() {
  // Query for player entity
  const [player] = useEntities(world.with('player', 'health'));
  
  if (!player) return null;
  
  return (
    <div>
      Health: {player.health.current} / {player.health.max}
    </div>
  );
}
```

## System Update Pattern

```typescript
// Systems run in useFrame
function useHealthSystem() {
  const entities = world.with('health', 'regen');
  
  useFrame((state, delta) => {
    for (const entity of entities) {
      if (entity.health.current < entity.health.max) {
        entity.health.current = Math.min(
          entity.health.max,
          entity.health.current + entity.regen.rate * delta
        );
      }
    }
  });
}
```

## Component Addition/Removal (Runtime)

```typescript
// Add component
world.addComponent(entity, 'stunned', { duration: 2.0 });

// Remove component
world.removeComponent(entity, 'stunned');

// Check existence
if ('stunned' in entity) {
  // Entity is stunned
}
```

## Zustand + ECS Bridge

```typescript
// Sync ECS data to Zustand for UI
function useECSSync() {
  const updateUI = useGameStore(s => s.updateUI);
  
  useFrame(() => {
    const [player] = world.with('player', 'health', 'transform');
    if (!player) return;
    
    updateUI({
      health: player.health.current,
      position: player.transform.position.toArray(),
    });
  });
}
```

## Tags Pattern (Flexible Grouping)

```typescript
// Good for dynamic categorization
export function createEnemy(type: string, position: Vector3) {
  return world.add({
    tags: new Set(['enemy', type, 'hostile']),
    transform: { position, /* ... */ },
    health: { /* ... */ },
  });
}

// Query by tag
function getDamageableEntities() {
  return world.with('tags', 'health').filter(e => 
    e.tags.has('enemy') || e.tags.has('npc')
  );
}
```

## Performance Tips

1. **Batch updates** - Don't add/remove components in tight loops
2. **Use archetypes** - Pre-define common entity types
3. **Avoid deep nesting** - Keep component data flat
4. **Cache queries** - Don't recreate archetype queries every frame
5. **Minimize watchers** - Only use `useEntities` when React needs updates

## Anti-Patterns

### ❌ God Components
```typescript
// Bad - Kitchen sink component
interface EntityComponent {
  health: number;
  position: Vector3;
  inventory: Item[];
  quests: Quest[];
  // ... 50 more fields
}

// Good - Split into focused components
interface HealthComponent { current: number; max: number; }
interface TransformComponent { position: Vector3; /* ... */ }
interface InventoryComponent { items: Item[]; slots: number; }
```

### ❌ Component Mutation Outside Systems
```typescript
// Bad - Direct mutation in React component
function AttackButton() {
  const [enemy] = useEntities(world.with('enemy'));
  
  const handleClick = () => {
    enemy.health.current -= 10; // ❌ Breaks reactivity
  };
}

// Good - Use command pattern or events
function AttackButton() {
  const attackEnemy = useGameStore(s => s.attackEnemy);
  
  const handleClick = () => {
    attackEnemy(enemyId); // System handles mutation
  };
}
```

### ❌ Circular Dependencies
```typescript
// Bad - Components reference each other
interface OwnerComponent {
  owned: Entity[]; // ❌ Entities referencing entities
}

// Good - Use IDs or tags
interface OwnerComponent {
  ownedIds: string[];
}
```



<!-- Source: .ruler/react_three_fiber.md -->

# React Three Fiber Development Guidelines

## Component Structure

### Scene Organization
```tsx
// Bad - Everything in one component
function Game() {
  return (
    <Canvas>
      <mesh>...</mesh>
      <mesh>...</mesh>
      <mesh>...</mesh>
      {/* 500 more lines */}
    </Canvas>
  );
}

// Good - Hierarchical composition
function Game() {
  return (
    <Canvas>
      <Scene />
      <Effects />
    </Canvas>
  );
}

function Scene() {
  return (
    <>
      <Environment />
      <Terrain />
      <Characters />
      <Props />
    </>
  );
}
```

## Performance Patterns

### Instancing (MANDATORY for >10 similar objects)
```tsx
import { Instance, Instances } from '@react-three/drei';

function Forest() {
  return (
    <Instances limit={1000} range={1000}>
      <treeGeometry />
      <meshStandardMaterial />
      {trees.map((pos, i) => (
        <Instance key={i} position={pos} />
      ))}
    </Instances>
  );
}
```

### LOD Implementation
```tsx
import { Detailed } from '@react-three/drei';

function Tree({ position }) {
  return (
    <Detailed distances={[0, 15, 30]}>
      <TreeHighPoly position={position} />
      <TreeMediumPoly position={position} />
      <TreeLowPoly position={position} />
    </Detailed>
  );
}
```

### Texture Loading
```tsx
import { useTexture } from '@react-three/drei';

// Good - Preload and cache
const TEXTURE_PATHS = {
  grass: '/textures/grass.png',
  sand: '/textures/sand.jpg',
} as const;

function Terrain() {
  const textures = useTexture(TEXTURE_PATHS);
  // textures.grass, textures.sand are now loaded
}
```

## Camera Setup

### Diorama Camera (Project Standard)
```tsx
import { PerspectiveCamera } from '@react-three/drei';

function DioramaCamera({ target }) {
  return (
    <PerspectiveCamera
      makeDefault
      position={[8, 5, 8]}
      fov={50}
      near={0.1}
      far={1000}
    />
  );
}
```

## Post-Processing Stack (MANDATORY ORDER)

```tsx
import { EffectComposer, Bloom, DepthOfField, SSAO } from '@react-three/postprocessing';

function Effects() {
  return (
    <EffectComposer>
      {/* 1. Bloom */}
      <Bloom luminanceThreshold={0.9} intensity={0.5} />
      
      {/* 2. Depth of Field */}
      <DepthOfField focusDistance={0} focalLength={0.02} bokehScale={2} />
      
      {/* 3. SSAO */}
      <SSAO samples={31} radius={5} intensity={40} />
      
      {/* 4. God Rays (custom) */}
      <GodRays />
      
      {/* 5. Color Grading (custom) */}
      <ColorGrading />
    </EffectComposer>
  );
}
```

## State Management with R3F

### Frame Loop Integration
```tsx
import { useFrame } from '@react-three/fiber';

function AnimatedObject() {
  const ref = useRef();
  
  useFrame((state, delta) => {
    // Good - Use delta for frame-rate independence
    ref.current.rotation.y += delta * 0.5;
    
    // Bad - Frame-dependent
    // ref.current.rotation.y += 0.01;
  });
  
  return <mesh ref={ref} />;
}
```

### Zustand Integration
```tsx
import { useGameStore } from '@/lib/stores/useGame';

function Player() {
  const position = useGameStore(s => s.player.position);
  const updatePosition = useGameStore(s => s.updatePlayerPosition);
  
  useFrame(() => {
    // Update ECS/Zustand from frame loop
    updatePosition(ref.current.position);
  });
}
```

## Mobile Optimization

### Conditional Quality
```tsx
import { useIsMobile } from '@/hooks/use-is-mobile';

function Water() {
  const isMobile = useIsMobile();
  
  return (
    <mesh>
      <planeGeometry args={[100, 100, isMobile ? 32 : 128]} />
      <waterMaterial 
        reflections={!isMobile}
        refractions={!isMobile}
      />
    </mesh>
  );
}
```

### Texture Resolution
```tsx
// Auto-detect and downscale
const textureSize = isMobile ? 1024 : 2048;
```

## Common Pitfalls

### ❌ Don't create geometries/materials in render
```tsx
// Bad
function Box() {
  return (
    <mesh>
      <boxGeometry args={[1, 1, 1]} /> {/* Created every frame! */}
      <meshStandardMaterial color="red" />
    </mesh>
  );
}

// Good
const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
const redMaterial = new THREE.MeshStandardMaterial({ color: 'red' });

function Box() {
  return <mesh geometry={boxGeometry} material={redMaterial} />;
}
```

### ❌ Don't use `useEffect` for animations
```tsx
// Bad - Race conditions, cleanup issues
useEffect(() => {
  const interval = setInterval(() => {
    ref.current.rotation.y += 0.01;
  }, 16);
  return () => clearInterval(interval);
}, []);

// Good - Use useFrame
useFrame((state, delta) => {
  ref.current.rotation.y += delta * 0.5;
});
```

## Testing R3F Components

```tsx
import { render } from '@react-three/test-renderer';

describe('Player', () => {
  it('renders at correct position', async () => {
    const renderer = await render(<Player position={[1, 2, 3]} />);
    const mesh = renderer.scene.children[0];
    expect(mesh.position.toArray()).toEqual([1, 2, 3]);
  });
});
```



<!-- Source: .ruler/shaders.md -->

# Shader Development Guidelines (GLSL)

## Naming Conventions (MANDATORY)

```glsl
// Uniforms - Global parameters
uniform float u_time;
uniform vec2 u_resolution;
uniform sampler2D u_texture;

// Attributes - Per-vertex data
attribute vec3 a_position;
attribute vec2 a_uv;

// Varyings - Vertex → Fragment interpolation
varying vec2 v_uv;
varying vec3 v_worldPosition;

// Constants - Uppercase
const float PI = 3.14159265359;
const float MAX_DISTANCE = 1000.0;
```

## Mobile Shader Optimization

### Precision Qualifiers (Critical for Mobile)
```glsl
// Fragment shader header
precision mediump float; // Default for mobile

// High precision only when necessary
uniform highp sampler2D u_texture;
varying highp vec3 v_position; // If needed for calculations

// Low precision for colors, normals
varying lowp vec3 v_normal;
varying lowp vec4 v_color;
```

### Branch Avoidance
```glsl
// Bad - Branching kills performance on mobile
float result;
if (value > 0.5) {
  result = complexCalculation(value);
} else {
  result = simpleCalculation(value);
}

// Good - Use step() or mix()
float t = step(0.5, value); // 0.0 or 1.0
float result = mix(
  simpleCalculation(value),
  complexCalculation(value),
  t
);
```

## Water Shader Pattern (Gerstner Waves)

```glsl
// Vertex Shader
uniform float u_time;
uniform vec4 u_waves[4]; // [amplitude, wavelength, speed, direction]

vec3 gerstnerWave(vec3 pos, vec4 wave) {
  float k = 2.0 * PI / wave.y; // Wavelength → frequency
  float c = sqrt(9.8 / k); // Wave speed
  vec2 d = normalize(wave.zw); // Direction
  float f = k * (dot(d, pos.xz) - c * u_time);
  
  return vec3(
    d.x * wave.x * cos(f),
    wave.x * sin(f),
    d.y * wave.x * cos(f)
  );
}

void main() {
  vec3 pos = position;
  
  // Sum multiple waves
  pos += gerstnerWave(position, u_waves[0]);
  pos += gerstnerWave(position, u_waves[1]);
  pos += gerstnerWave(position, u_waves[2]);
  pos += gerstnerWave(position, u_waves[3]);
  
  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  v_worldPosition = pos;
}
```

## SDF (Signed Distance Field) Patterns

```glsl
// Basic SDF shapes
float sdSphere(vec3 p, float r) {
  return length(p) - r;
}

float sdBox(vec3 p, vec3 b) {
  vec3 q = abs(p) - b;
  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

// SDF operations
float opUnion(float d1, float d2) {
  return min(d1, d2);
}

float opSubtraction(float d1, float d2) {
  return max(-d1, d2);
}

float opIntersection(float d1, float d2) {
  return max(d1, d2);
}

// Smooth union (organic blending)
float opSmoothUnion(float d1, float d2, float k) {
  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
  return mix(d2, d1, h) - k * h * (1.0 - h);
}
```

## Noise Functions (Include from glsl-noise)

```glsl
// Import via vite-plugin-glsl
#pragma glslify: snoise3 = require('glsl-noise/simplex/3d')
#pragma glslify: cnoise3 = require('glsl-noise/classic/3d')

// Fractal Brownian Motion (terrain)
float fbm(vec3 p) {
  float value = 0.0;
  float amplitude = 0.5;
  float frequency = 1.0;
  
  for (int i = 0; i < 4; i++) {
    value += amplitude * snoise3(p * frequency);
    frequency *= 2.0;
    amplitude *= 0.5;
  }
  
  return value;
}
```

## Caustics Shader (Water Refraction)

```glsl
// Fragment shader
uniform sampler2D u_causticsTexture;
uniform float u_time;

void main() {
  // Distort UVs with animated noise
  vec2 uv1 = v_uv + vec2(u_time * 0.1, u_time * 0.05);
  vec2 uv2 = v_uv - vec2(u_time * 0.08, u_time * 0.12);
  
  float caustic1 = texture2D(u_causticsTexture, uv1).r;
  float caustic2 = texture2D(u_causticsTexture, uv2).r;
  
  // Combine for organic movement
  float caustics = min(caustic1, caustic2);
  
  // Apply to base color
  vec3 color = v_baseColor + caustics * 0.3;
  gl_FragColor = vec4(color, 1.0);
}
```

## Depth-Based Color (Water Clarity)

```glsl
uniform sampler2D u_depthTexture;
uniform vec3 u_shallowColor;
uniform vec3 u_deepColor;
uniform float u_depthFalloff;

void main() {
  // Read depth from depth buffer
  float depth = texture2D(u_depthTexture, gl_FragCoord.xy / u_resolution).r;
  
  // Convert to world space depth
  float waterDepth = linearizeDepth(depth);
  
  // Mix colors based on depth
  float depthFactor = 1.0 - exp(-waterDepth * u_depthFalloff);
  vec3 color = mix(u_shallowColor, u_deepColor, depthFactor);
  
  gl_FragColor = vec4(color, 1.0);
}
```

## Shader Integration with R3F

```tsx
import { shaderMaterial } from '@react-three/drei';
import { extend } from '@react-three/fiber';
import vertexShader from './shaders/water.vert';
import fragmentShader from './shaders/water.frag';

const WaterMaterial = shaderMaterial(
  {
    u_time: 0,
    u_waves: [
      [0.05, 2.0, 1.0, 1.0, 0.0],
      [0.03, 1.5, 0.8, 0.7, 0.7],
    ],
  },
  vertexShader,
  fragmentShader
);

extend({ WaterMaterial });

// Usage
function Water() {
  const ref = useRef();
  
  useFrame((state) => {
    ref.current.u_time = state.clock.elapsedTime;
  });
  
  return (
    <mesh>
      <planeGeometry args={[100, 100, 128, 128]} />
      <waterMaterial ref={ref} />
    </mesh>
  );
}
```

## Common Pitfalls

### ❌ Expensive Operations in Fragment Shader
```glsl
// Bad - sqrt/sin/cos every pixel!
for (int i = 0; i < 100; i++) {
  color += sin(i * 0.1) * texture2D(u_tex, uv);
}

// Good - Pre-calculate in vertex or CPU
uniform float u_precomputedValues[100];
```

### ❌ Texture Reads in Loops
```glsl
// Bad
for (int i = 0; i < 8; i++) {
  color += texture2D(u_texture, uv + offsets[i]);
}

// Better - Unroll loop manually
color += texture2D(u_texture, uv + offsets[0]);
color += texture2D(u_texture, uv + offsets[1]);
// ... etc (compiler can optimize)
```

## Debugging Shaders

```glsl
// Visualize UVs
gl_FragColor = vec4(v_uv, 0.0, 1.0);

// Visualize normals
gl_FragColor = vec4(v_normal * 0.5 + 0.5, 1.0);

// Visualize depth
gl_FragColor = vec4(vec3(depth), 1.0);
```
