# Rivermarsh - 3D Otter Adventure Game

## Overview
Rivermarsh is a cozy 3D adventure/RPG where players explore a marshland as an otter. The game blends exploration, fishing, questing, and relationship building, aiming for a "Zelda: Breath of the Wild meets Stardew Valley" feel. It emphasizes realistic water physics, environmental interaction, and a dynamic world. Targeting web and mobile (iOS/Android), it features a painterly visual style and is optimized for 60 FPS on mid-tier devices.

## User Preferences
- Speak like a normal human, not a corporate robot
- Short sentences when possible
- No fake enthusiasm
- Call things what they are
- Prefer working, beautiful code over "correct" architecture

## System Architecture
The game is built with React 18, TypeScript, React Three Fiber, @react-three/drei, ecctrl for physics, and Zustand for state management. Styling uses Vite with vanilla-extract or Tailwind + clsx, and GLSL for shaders. Capacitor handles mobile builds, and Howler.js is for audio. The project avoids Redux, Recoil, MobX, Jotai, Signals, Unity, and Godot.

A strict folder structure is enforced: `src/components`, `src/systems`, `src/scenes`, `src/shaders`, `src/lib`, `src/stores`, `src/assets`, and `App.tsx`.

Rendering uses SDF/raymarched details, InstancedMesh for repeated elements, and marching cubes for dynamic terrain. A mandatory post-processing stack includes Bloom, Depth of Field, SSAO/SSDO, God rays, and color grading. Mobile performance is optimized with LODs, 1K max textures, BC7 compression, and GPU-driven rendering.

Global state is managed by `useGameStore.ts`. Input is mobile-first, using ecctrl for movement and nipplejs for camera/action. The camera uses a smooth-following, angled-down diorama view.

The 4km Ã— 4km world is procedurally generated using layered simplex noise, streamed in 256m chunks. Biomes are driven by height, moisture, and temperature, with pre-made structures placed on valid terrain.

The water system features Gerstner waves, caustics, depth-based coloring, refraction, reflection, and otter wake trails. Combat is real-time, pausable, stamina-based, with three attack types. Enemy AI uses simple steering behaviors. Quest and dialogue systems are JSON-based with flags stored in Zustand, and NPCs follow schedules.

Performance targets are strict: iPhone 13 (60 FPS, <150 Draw Calls), Mid Android (50-60 FPS, <200 Draw Calls), and Desktop (120+ FPS, <300 Draw Calls). Optimization strategies include instancing, chunking, LOD, GPU culling, and shader optimization. Development mandates no new dependencies without approval, mobile-first feature development, shader fallbacks, accurate UI, a day-one save system, and strict scope.

Key architectural standards include:
- **ECS + Rendering:** Mandatory system execution order, hybrid rendering (JSX for static, InstancedMesh for dense), a 3x3 active chunk window, and a specific post-processing stack order.
- **Material UI Integration:** UI components receive throttled snapshots from `useUIState` Zustand store, with mandatory responsive design across breakpoints.
- **Yuka AI Integration:** Yuka Vehicle/StateMachine pools are prewarmed, with bridges bound on `SpawnSystem` hooks. Specific state machine definitions and steering behavior weights are mandated for different animal types, alongside performance optimizations like tiered update frequencies and spatial indexing.

## External Dependencies
**Database & Backend:**
- Drizzle ORM with PostgreSQL
- Express server with Vite middleware

**Asset Management:**
- Textures
- Audio files (MP3/OGG/WAV)
- 3D models (GLTF/GLB)
- Font: Inter via @fontsource

**UI Libraries:**
- Radix UI for accessible primitives
- Lucide React for icons
- Tailwind CSS + clsx for styling

**3D Graphics:**
- @react-three/drei
- @react-three/postprocessing
- vite-plugin-glsl for shader imports

**Python Tooling (Build-time only):**
- Meshy SDK: for 3D model, texture, and animation generation (Webhook-only)
- CrewAI agents: for autonomous game system building
- `uv` for package management
- `httpx`, `tenacity`, `rich`, `playwright` (Meshy SDK dependencies)
- `crewai[anthropic]`, `litellm` (CrewAI dependencies)
- `pytest` for testing