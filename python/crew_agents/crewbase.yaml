
version: "2.0"
name: "rivermarsh_development_crew"

# ============================================================================
# AGENT DEFINITIONS - Specialized roles with focused responsibilities
# ============================================================================
agents:
  technical_director:
    role: "Technical Director & Workflow Coordinator"
    goal: "Orchestrate Alpha→Work→Omega workflow, delegate to specialists, validate deliverables"
    backstory: |
      You are an experienced technical director who understands how to decompose complex
      game development into vertical slices. You validate each slice before proceeding,
      ensure proper handoffs between specialists, and maintain architectural coherence.
      You understand when to parallelize work and when sequential validation is critical.
    llm: "openrouter/anthropic/claude-3.7-sonnet"
    max_iter: 40
    max_reasoning_attempts: 5
    allow_delegation: true
    tools:
      - "mcp://git/execute_command"
      - "mcp://filesystem/read_file"
      - "mcp://filesystem/write_file"
      - "mcp://conport/get_conport_schema"

  project_manager:
    role: "Project Manager (Alpha Agent - Context Reader)"
    goal: "Analyze projectbrief.md and ConPort, identify blockers, validate prerequisites"
    backstory: |
      You start every workflow by reading complete project context. You identify missing
      information, blockers, dependencies, and required resources. You create actionable
      checklists and validation criteria for downstream tasks.
    llm: "openrouter/anthropic/claude-3.5-sonnet"
    max_iter: 25
    tools:
      - "mcp://conport/get_conport_schema"
      - "mcp://filesystem/read_file"
      - "mcp://git/execute_command"

  ecs_architect:
    role: "ECS & Data Architecture Lead"
    goal: "Design type-safe ECS schemas, validate data contracts, ensure zero TypeScript errors"
    backstory: |
      You specialize in Entity Component System design with Miniplex and TypeScript.
      You create minimal, focused schemas that solve ONE problem well. You validate
      against existing patterns and ensure backward compatibility.
    llm: "openrouter/anthropic/claude-3.5-sonnet"
    max_iter: 30
    max_reasoning_attempts: 3
    tools:
      - "mcp://filesystem/read_file"
      - "mcp://filesystem/write_file"
      - "mcp://git/execute_command"

  rendering_engineer:
    role: "3D Graphics & Rendering Engineer"
    goal: "Build performant React Three Fiber scenes, optimize shaders, maintain 60fps"
    backstory: |
      You create stunning R3F/Three.js visuals with GLSL shaders while maintaining
      60fps on mobile. You understand the post-processing pipeline requirements and
      mobile performance constraints.
    llm: "openrouter/anthropic/claude-3.5-sonnet"
    max_iter: 30
    max_reasoning_attempts: 3
    tools:
      - "mcp://filesystem/read_file"
      - "mcp://filesystem/write_file"
      - "mcp://vite/vite_start"

  integration_specialist:
    role: "Frontend Integration Specialist"
    goal: "Connect backend deliverables to R3F frontend, validate end-to-end flow"
    backstory: |
      You specialize in integrating backend systems with React Three Fiber frontends.
      You create adapters, validate type contracts, and ensure smooth data flow from
      ECS to rendering pipeline.
    llm: "openrouter/anthropic/claude-3.5-sonnet"
    max_iter: 30
    tools:
      - "mcp://filesystem/read_file"
      - "mcp://filesystem/write_file"
      - "mcp://vite/vite_start"

  qa_validator:
    role: "Quality Assurance & Validation Specialist"
    goal: "Validate deliverables against acceptance criteria, run tests, verify performance"
    backstory: |
      You validate that deliverables meet all acceptance criteria. You run unit tests,
      check TypeScript compilation, measure performance, and create validation reports.
      You identify gaps before human-in-the-loop review.
    llm: "openrouter/anthropic/claude-3.5-sonnet"
    max_iter: 25
    tools:
      - "mcp://filesystem/read_file"
      - "mcp://git/execute_command"
      - "mcp://playwright/execute"

  technical_writer:
    role: "Technical Writer (Omega Agent - Context Writer)"
    goal: "Document decisions, update ConPort, create integration guides"
    backstory: |
      You end every workflow by updating ConPort with decisions and progress.
      You create clear, actionable documentation that the next agent or human
      can use to continue work.
    llm: "openrouter/anthropic/claude-3.5-sonnet"
    max_iter: 25
    tools:
      - "mcp://conport/get_conport_schema"
      - "mcp://filesystem/write_file"

# ============================================================================
# TASK DEFINITIONS - Proper decomposition with cascading dependencies
# ============================================================================
tasks:
  # -------------------------------------------------------------------------
  # PHASE 0: ALPHA - Context Loading & Validation
  # -------------------------------------------------------------------------
  alpha_context_load:
    description: |
      ALPHA TASK: Load complete project context before any work begins.
      
      Actions:
      1. Read projectbrief.md for project goals and constraints
      2. Query ConPort schema to understand current state
      3. Read .ruler/ files for architectural patterns
      4. Identify any missing prerequisites or blockers
      
      Validation Criteria:
      - All context files are accessible
      - No critical blockers identified
      - Prerequisites are documented
      
      Output Format: Markdown checklist with:
      - [ ] Context item loaded
      - [ ] Prerequisite validated
      - [ ] Blocker identified (if any)
    expected_output: |
      Markdown report with:
      ## Context Loaded
      - List of files read
      - Current project state summary
      
      ## Prerequisites
      - [ ] Checklist of validated prerequisites
      
      ## Blockers (if any)
      - Description of any blockers
      
      ## Ready to Proceed
      - Yes/No with reasoning
    agent: project_manager
    human_input: false

  # -------------------------------------------------------------------------
  # PHASE 1: FOUNDATION - Parallel schema validation
  # -------------------------------------------------------------------------
  validate_ecs_component_schemas:
    description: |
      Validate existing ECS component schemas in client/src/ecs/components/.
      
      Focus Areas:
      1. TypeScript compilation with zero errors
      2. Adherence to Miniplex patterns (check client/.ruler/ecs_patterns.md)
      3. Type exports are complete and correct
      4. Component schemas are minimal and focused
      
      DO NOT create new components. ONLY validate existing ones.
      
      Validation Steps:
      1. Run `npm run typecheck` in client/
      2. Check each component file against patterns
      3. Verify type exports exist
      4. Document any issues found
      
      If issues found: Create a remediation plan, do NOT fix yet.
    expected_output: |
      ## Validation Report
      
      ### TypeScript Compilation
      - Status: PASS/FAIL
      - Errors: (list if any)
      
      ### Pattern Compliance
      - AIComponent.ts: PASS/FAIL (reasoning)
      - AnimationComponent.ts: PASS/FAIL (reasoning)
      - [continue for all components]
      
      ### Type Exports
      - Complete: YES/NO
      - Missing: (list if any)
      
      ### Remediation Plan (if needed)
      - Issue 1: [description] → [fix]
      - Issue 2: [description] → [fix]
      
      ### Ready for Next Phase
      - YES/NO with reasoning
    agent: ecs_architect
    context: [alpha_context_load]
    async_execution: false

  validate_dfu_data_contracts:
    description: |
      Validate Daggerfall Unity data mappings in shared/backend/dfu_analysis/.
      
      Focus Areas:
      1. biomes.json structure matches BiomeContract.ts
      2. species.json structure matches SpeciesContract.ts
      3. Data completeness (no missing required fields)
      4. Type safety between backend and frontend contracts
      
      DO NOT modify contracts yet. ONLY validate.
      
      Validation Steps:
      1. Load shared/contracts/*.ts
      2. Load shared/backend/dfu_analysis/mappings/*.json
      3. Verify structural alignment
      4. Check for missing data
      5. Document any mismatches
    expected_output: |
      ## Contract Validation Report
      
      ### BiomeContract Alignment
      - Structure matches: YES/NO
      - Missing fields: (list if any)
      - Type mismatches: (list if any)
      
      ### SpeciesContract Alignment
      - Structure matches: YES/NO
      - Missing fields: (list if any)
      - Type mismatches: (list if any)
      
      ### Data Completeness
      - Biomes: X/Y complete
      - Species: X/Y complete
      
      ### Remediation Plan (if needed)
      - Issue 1: [description] → [fix]
      
      ### Ready for Next Phase
      - YES/NO with reasoning
    agent: ecs_architect
    context: [alpha_context_load]
    async_execution: false

  # -------------------------------------------------------------------------
  # CONDITIONAL: Fix foundation if validation failed
  # -------------------------------------------------------------------------
  fix_foundation_issues:
    description: |
      CONDITIONAL TASK: Only runs if validation tasks identified issues.
      
      Condition: Check previous task outputs for FAIL status or remediation plans.
      
      Actions:
      1. Review all remediation plans from validation tasks
      2. Prioritize fixes by impact (blocking vs. non-blocking)
      3. Apply fixes for blocking issues only
      4. Re-run validation to confirm fixes
      
      DO NOT scope creep. Fix ONLY documented issues.
    expected_output: |
      ## Fixes Applied
      
      ### Blocking Issues Fixed
      - Issue 1: [description] → [action taken] → [validated]
      
      ### Non-Blocking Issues Deferred
      - Issue 1: [description] → [deferred to phase X]
      
      ### Re-validation Results
      - ECS Schemas: PASS/FAIL
      - DFU Contracts: PASS/FAIL
      
      ### Ready to Proceed
      - YES/NO with reasoning
    agent: ecs_architect
    context: [validate_ecs_component_schemas, validate_dfu_data_contracts]
    condition: |
      lambda outputs: any(
        'FAIL' in str(output.raw) or 'Remediation Plan' in str(output.raw) 
        for output in outputs if output
      )

  # -------------------------------------------------------------------------
  # PHASE 2: PROTOTYPE 1 - Biome/Weather/Day Cycle (Sequential)
  # -------------------------------------------------------------------------
  design_biome_rendering_slice:
    description: |
      Design the minimal vertical slice for Biome/Weather/DayNight rendering.
      
      Scope Definition:
      1. Identify MINIMUM components needed for biome diorama
      2. Define shader requirements (sky, ground, lighting)
      3. Specify ECS integration points
      4. Create acceptance criteria
      
      Deliverables:
      1. Technical design document (markdown)
      2. Component dependency graph
      3. Shader specification
      4. Acceptance criteria checklist
      
      Constraints:
      - Must work with EXISTING ECS schemas (no new components)
      - Must use existing post-processing pipeline
      - Must maintain 60fps on mobile
      
      This is DESIGN only. No implementation yet.
    expected_output: |
      ## Biome Rendering Vertical Slice Design
      
      ### Scope
      - Components used: [list]
      - Shaders required: [list]
      - Integration points: [list]
      
      ### Component Dependencies
      ```
      [ASCII dependency graph]
      ```
      
      ### Shader Specifications
      #### Sky Shader
      - Inputs: [list]
      - Outputs: [list]
      - Algorithm: [description]
      
      #### Ground Shader
      [same format]
      
      ### ECS Integration
      - BiomeComponent → [how it drives rendering]
      - TimeOfDayComponent → [how it affects shaders]
      - WeatherComponent → [how it affects scene]
      
      ### Acceptance Criteria
      - [ ] Biome selector UI works
      - [ ] Day/night cycle animates smoothly
      - [ ] Weather transitions are visible
      - [ ] 60fps maintained on iPhone 13
      - [ ] No console errors
      
      ### Estimated Complexity
      - Low/Medium/High with reasoning
    agent: rendering_engineer
    context: [validate_ecs_component_schemas, validate_dfu_data_contracts]
    depends_on:
      - validate_ecs_component_schemas: "process_completed_successfully"
      - validate_dfu_data_contracts: "process_completed_successfully"

  implement_biome_shaders:
    description: |
      Implement ONLY the shader code for biome rendering.
      
      Scope:
      - Create/modify shader files based on design spec
      - Implement sky gradient shader
      - Implement ground SDF shader
      - Add time-of-day lighting calculations
      
      Constraints:
      - Use existing shader patterns from client/.ruler/shaders.md
      - Maintain GLSL ES 3.0 compatibility (mobile)
      - Keep shader complexity LOW (mobile performance)
      
      DO NOT implement React components yet. Shaders only.
    expected_output: |
      ## Shader Implementation
      
      ### Files Modified/Created
      - path/to/SkyShader.glsl: [description]
      - path/to/GroundShader.glsl: [description]
      
      ### Shader Features
      #### Sky Shader
      - Time-of-day gradient: IMPLEMENTED
      - Weather effects: IMPLEMENTED
      - Performance: [ms per frame]
      
      #### Ground Shader
      - SDF terrain: IMPLEMENTED
      - Biome coloring: IMPLEMENTED
      - Performance: [ms per frame]
      
      ### Validation
      - Compiles without errors: YES/NO
      - Mobile compatible: YES/NO
      - Performance target met: YES/NO
      
      ### Ready for Integration
      - YES/NO with reasoning
    agent: rendering_engineer
    context: [design_biome_rendering_slice]

  implement_biome_r3f_components:
    description: |
      Implement React Three Fiber components that USE the shaders.
      
      Scope:
      - Create/modify R3F components for biome scene
      - Connect ECS state to shader uniforms
      - Implement control UI (biome selector, time slider, weather toggle)
      
      Integration Points:
      - BiomeComponent → shader material props
      - TimeOfDayComponent → sky shader uniforms
      - WeatherComponent → weather effects toggle
      
      Reference: client/.ruler/react_three_fiber.md for patterns
    expected_output: |
      ## R3F Component Implementation
      
      ### Components Created/Modified
      - BiomeDiorama.tsx: [description]
      - BiomeControls.tsx: [description]
      - SDFGround.tsx: [description]
      - SDFSky.tsx: [description]
      
      ### ECS Integration
      - useBiomeECS hook: [connects ECS to R3F]
      - State flow: BiomeComponent → uniforms → shaders
      
      ### UI Controls
      - Biome selector: IMPLEMENTED
      - Time of day slider: IMPLEMENTED
      - Weather toggle: IMPLEMENTED
      
      ### Validation
      - TypeScript compiles: YES/NO
      - Controls functional: YES/NO
      - Performance: [fps on test device]
      
      ### Ready for QA
      - YES/NO with reasoning
    agent: rendering_engineer
    context: [implement_biome_shaders]

  validate_biome_prototype:
    description: |
      Run automated validation of the biome prototype.
      
      Validation Steps:
      1. Run TypeScript compilation: `npm run typecheck`
      2. Start dev server and load prototype
      3. Test all acceptance criteria from design phase
      4. Measure performance metrics
      5. Check for console errors/warnings
      
      DO NOT fix issues. ONLY document them for review.
    expected_output: |
      ## Biome Prototype Validation Report
      
      ### TypeScript Compilation
      - Status: PASS/FAIL
      - Errors: [list if any]
      
      ### Acceptance Criteria Results
      - [ ] Biome selector UI works: PASS/FAIL
      - [ ] Day/night cycle animates: PASS/FAIL
      - [ ] Weather transitions visible: PASS/FAIL
      - [ ] 60fps maintained: PASS/FAIL (actual: X fps)
      - [ ] No console errors: PASS/FAIL
      
      ### Performance Metrics
      - Average FPS: X
      - Frame time: X ms
      - Memory usage: X MB
      
      ### Issues Found
      - Critical: [list]
      - Non-critical: [list]
      
      ### Recommendation
      - APPROVE for HITL review
      - FIX ISSUES before HITL review
      
      ### Screenshots/Evidence
      - [paths to screenshots if taken]
    agent: qa_validator
    context: [implement_biome_r3f_components]
    human_input: true  # HITL approval checkpoint

  # -------------------------------------------------------------------------
  # PHASE 3: PROTOTYPE 2 - Animated GLB Creature (Sequential after P1)
  # -------------------------------------------------------------------------
  design_creature_animation_slice:
    description: |
      Design minimal vertical slice for GLB creature with reactive animations.
      
      Scope Definition:
      1. Define creature component requirements (extends existing ECS)
      2. Specify animation triggers (buttons, movement, state changes)
      3. Design GLB loading and caching strategy
      4. Create acceptance criteria
      
      Context:
      - Builds on biome prototype (creature in foreground)
      - Uses existing AnimationComponent from ECS
      - References Meshy pipeline for asset source
      
      Constraints:
      - Must use EXISTING AnimationComponent
      - Animations must be from Meshy catalog
      - Must maintain 60fps with creature + biome
    expected_output: |
      ## Creature Animation Vertical Slice Design
      
      ### Scope
      - New components needed: [list or NONE]
      - ECS components used: AnimationComponent, [others]
      - Animation triggers: [button A → idle, direction → walk, etc.]
      
      ### Architecture
      ```
      [Component interaction diagram]
      ```
      
      ### GLB Loading Strategy
      - Asset source: Meshy API / local cache
      - Loading: [lazy/eager]
      - Caching: [strategy]
      
      ### Animation State Machine
      ```
      idle → walk (on movement)
      walk → attack (on button press)
      attack → idle (on completion)
      ```
      
      ### Acceptance Criteria
      - [ ] GLB model loads correctly
      - [ ] Animations transition smoothly
      - [ ] Button controls work
      - [ ] Direction changes affect animation
      - [ ] 60fps maintained with biome+creature
      - [ ] Mobile performance acceptable
      
      ### Integration with Prototype 1
      - Biome remains functional: [how]
      - Camera adjustments: [if needed]
      - UI additions: [creature controls]
      
      ### Estimated Complexity
      - Low/Medium/High with reasoning
    agent: rendering_engineer
    context: [validate_biome_prototype]
    depends_on:
      validate_biome_prototype: "process_completed_successfully"

  implement_glb_loader:
    description: |
      Implement GLB loading and caching system.
      
      Scope:
      - Create GLB loader utility
      - Implement asset caching
      - Add loading states
      - Handle errors gracefully
      
      Integration:
      - Connect to Meshy toolkit if using generated assets
      - Use React Three Fiber's useGLTF hook
      - Cache in browser storage
    expected_output: |
      ## GLB Loader Implementation
      
      ### Files Created/Modified
      - lib/glbLoader.ts: [description]
      - hooks/useCreatureModel.ts: [description]
      
      ### Features
      - Asset loading: IMPLEMENTED
      - Caching: IMPLEMENTED
      - Loading states: IMPLEMENTED
      - Error handling: IMPLEMENTED
      
      ### Performance
      - Load time (cached): X ms
      - Load time (uncached): X ms
      - Memory footprint: X MB
      
      ### Validation
      - TypeScript compiles: YES/NO
      - Unit tests pass: YES/NO
      
      ### Ready for Integration
      - YES/NO with reasoning
    agent: integration_specialist
    context: [design_creature_animation_slice]

  implement_creature_animations:
    description: |
      Implement creature component with reactive animations.
      
      Scope:
      - Create creature R3F component
      - Connect AnimationComponent to animation mixer
      - Implement state machine for animation transitions
      - Add control UI (attack button, direction controls)
      
      Reference existing OtterNPC.tsx for patterns.
    expected_output: |
      ## Creature Animation Implementation
      
      ### Components Created/Modified
      - components/CreatureNPC.tsx: [description]
      - components/CreatureControls.tsx: [description]
      - hooks/useCreatureAnimations.ts: [description]
      
      ### Animation State Machine
      - States: idle, walk, attack
      - Transitions: [as designed]
      - Triggers: [button events, movement]
      
      ### ECS Integration
      - AnimationComponent → animation mixer
      - State updates → ECS world
      
      ### UI Controls
      - Attack button: IMPLEMENTED
      - Direction pad: IMPLEMENTED
      - Animation state display: IMPLEMENTED
      
      ### Validation
      - TypeScript compiles: YES/NO
      - Animations play correctly: YES/NO
      - Performance: [fps with creature+biome]
      
      ### Ready for QA
      - YES/NO with reasoning
    agent: rendering_engineer
    context: [implement_glb_loader]

  validate_creature_prototype:
    description: |
      Validate creature animation prototype against acceptance criteria.
      
      Validation Steps:
      1. TypeScript compilation
      2. Load prototype with biome + creature
      3. Test all animation triggers
      4. Measure performance with both systems
      5. Check for regressions in biome functionality
    expected_output: |
      ## Creature Prototype Validation Report
      
      ### TypeScript Compilation
      - Status: PASS/FAIL
      
      ### Acceptance Criteria Results
      - [ ] GLB model loads: PASS/FAIL
      - [ ] Animations transition smoothly: PASS/FAIL
      - [ ] Button controls work: PASS/FAIL
      - [ ] Direction affects animation: PASS/FAIL
      - [ ] 60fps maintained: PASS/FAIL (actual: X fps)
      - [ ] Mobile performance OK: PASS/FAIL
      
      ### Performance Metrics
      - Average FPS (biome+creature): X
      - Frame time: X ms
      - Memory usage: X MB
      
      ### Regression Testing
      - Biome functionality: NOT BROKEN / BROKEN
      - Previous controls: WORKING / NOT WORKING
      
      ### Issues Found
      - Critical: [list]
      - Non-critical: [list]
      
      ### Recommendation
      - APPROVE for HITL review
      - FIX ISSUES before HITL review
    agent: qa_validator
    context: [implement_creature_animations]
    human_input: true  # HITL approval checkpoint

  # -------------------------------------------------------------------------
  # PHASE 4: ASSESSMENT - Plan Next Prototype
  # -------------------------------------------------------------------------
  assess_progress_and_plan_next:
    description: |
      STRATEGIC TASK: Assess completed prototypes and plan next vertical slice.
      
      Assessment Areas:
      1. Review what's been delivered (biome + creature prototypes)
      2. Identify gaps vs. final game vision
      3. Evaluate technical debt and refactoring needs
      4. Propose next logical vertical slice
      
      Planning Criteria:
      - Next slice should ADD capability, not redo existing work
      - Should be reasonably scoped (1-2 phases of work)
      - Should move toward playable game demo
      - Should address highest-risk unknowns
      
      Options for Next Slice (choose ONE):
      A. Multi-creature AI system (Yuka integration)
      B. Quest/dialogue system
      C. Terrain generation (procedural dungeons)
      D. Combat system (player vs. creatures)
      E. Other (specify)
      
      DO NOT implement. ONLY plan and get approval.
    expected_output: |
      ## Progress Assessment
      
      ### Delivered Capabilities
      - Prototype 1: Biome/Weather/DayNight rendering ✓
      - Prototype 2: Animated GLB creature ✓
      
      ### Gap Analysis
      - Missing for MVP: [list]
      - High-risk unknowns: [list]
      - Technical debt: [list]
      
      ### Proposed Next Vertical Slice
      **Selected Option**: [A/B/C/D/E]
      
      **Rationale**:
      - Addresses gap: [which gap]
      - Reduces risk: [which risk]
      - Builds on: [what we have]
      - Scope estimate: [time/complexity]
      
      ### Vertical Slice Breakdown
      1. Design Phase
         - Task 1: [description]
         - Task 2: [description]
      
      2. Implementation Phase
         - Task 1: [description]
         - Task 2: [description]
      
      3. Validation Phase
         - Task 1: [description]
      
      ### Approval Needed
      - Owner review required: YES
      - Estimated phases: X
      - Estimated agent-hours: Y
      
      ### Recommendation
      - PROCEED with this slice
      - DEFER (reason: [])
      - PIVOT to different slice (reason: [])
    agent: technical_director
    context: [validate_creature_prototype]
    human_input: true  # STRATEGIC checkpoint - owner decides next direction

  # -------------------------------------------------------------------------
  # PHASE: MESHY GLB VALIDATION - First Real Asset Test
  # -------------------------------------------------------------------------
  design_meshy_glb_test_sequence:
    description: |
      Design the Meshy GLB validation sequence for HITL review.
      
      This is the FIRST REAL use of Meshy API to generate reviewable assets.
      
      Required Sequence:
      1. Static sculptured otter (text-to-3D only)
      2. Default animated otter (walk/idle from default animations)
      3. Custom animated otter (attack animation from Meshy library)
      4. Retextured otter (different fur color - grey variant)
      5. Diorama integration (all 4 variants placed in biome scene)
      
      Prompt Engineering Requirements:
      - Read client/src/ecs/data/predatorSpecies.ts for otter.meshyPrompt
      - Use mesh_toolkit services for API calls
      - Define webhook URLs for completion tracking
      - Specify animation IDs from catalog (walk=1, attack=4)
      - Define retexture prompt (grey fur variant)
      
      Deliverables:
      1. Meshy API call specifications (prompts, art styles, animation IDs)
      2. Webhook handler endpoints (python/scripts/run_webhook_server.py)
      3. Expected GLB output paths (client/public/models/otter/*)
      4. HITL review prototype spec (diorama with 4 variants)
      
      Acceptance Criteria:
      - [ ] All 4 GLB variants generate successfully
      - [ ] Animations play correctly in prototype
      - [ ] HITL review UI is present and functional
      - [ ] Owner can rank 1-10 and REJECT/SAVE each variant
    expected_output: |
      ## Meshy GLB Test Sequence Design
      
      ### API Call Specifications
      
      #### 1. Static Sculptured Otter
      ```python
      text3d_service.submit_task(
          species="otter",
          prompt="sculpture style river otter standing upright...",
          art_style="sculpture",
          callback_url="http://0.0.0.0:8000/webhooks/meshy/otter/static"
      )
      ```
      
      #### 2. Default Animated Otter
      ```python
      # After static completes and is rigged
      animation_service.submit_task(
          species="otter",
          model_id=rigged_task_id,
          animation_id="1",  # Walk
          callback_url="http://0.0.0.0:8000/webhooks/meshy/otter/walk"
      )
      ```
      
      #### 3. Custom Animated Otter (Attack)
      ```python
      animation_service.submit_task(
          species="otter",
          model_id=rigged_task_id,
          animation_id="4",  # Attack
          callback_url="http://0.0.0.0:8000/webhooks/meshy/otter/attack"
      )
      ```
      
      #### 4. Retextured Grey Otter
      ```python
      retexture_service.submit_task(
          species="otter",
          model_id=base_task_id,
          prompt="grey fur with white chest, realistic texture",
          callback_url="http://0.0.0.0:8000/webhooks/meshy/otter/grey"
      )
      ```
      
      ### Expected File Structure
      ```
      client/public/models/otter/
      ├── static.glb           # Sculptured, no animation
      ├── walk.glb             # Default walk animation
      ├── attack.glb           # Custom attack animation
      └── grey_walk.glb        # Retextured grey variant
      ```
      
      ### HITL Review Prototype
      - Prototype ID: "meshy_glb_validation"
      - Extends: biome_selector_diorama
      - Renders: 4 otter variants in diorama scene
      - UI: HITL review controls (rating slider, notes, REJECT/SAVE)
      
      ### Ready for Implementation
      - YES with detailed specifications above
    agent: rendering_engineer
    context: [validate_biome_prototype]
    human_input: true

  implement_meshy_glb_pipeline:
    description: |
      Implement the Meshy GLB generation pipeline using mesh_toolkit.
      
      Scope:
      - python/scripts/generate_species_pipeline.py modifications
      - Webhook server setup (run_webhook_server.py)
      - GLB download and storage to client/public/models/
      - Manifest updates for tracking
      
      This uses EXISTING mesh_toolkit services - no new code needed there.
      
      Integration Steps:
      1. Start webhook server on port 8000
      2. Submit 4 Meshy tasks in sequence (static → rig → animate x2 + retexture)
      3. Wait for webhooks, download GLBs
      4. Update manifest.json for otter species
      5. Signal prototype that assets are ready
    expected_output: |
      ## Pipeline Implementation
      
      ### Files Modified/Created
      - python/scripts/generate_species_pipeline.py: [otter-specific sequence]
      - python/scripts/run_webhook_server.py: [webhook handlers]
      - client/public/models/otter/manifest.json: [tracking data]
      
      ### Webhook Server
      - Listening on: http://0.0.0.0:8000
      - Endpoints: /webhooks/meshy/otter/{static,walk,attack,grey}
      - Downloads GLBs to: client/public/models/otter/
      
      ### Pipeline Status
      - Static otter: SUCCEEDED (static.glb downloaded)
      - Rigging: SUCCEEDED (rigged model ready)
      - Walk animation: SUCCEEDED (walk.glb downloaded)
      - Attack animation: SUCCEEDED (attack.glb downloaded)
      - Grey retexture: SUCCEEDED (grey_walk.glb downloaded)
      
      ### Ready for Prototype Integration
      - YES with all 4 GLB files in public/models/otter/
    agent: integration_specialist
    context: [design_meshy_glb_test_sequence]

  implement_hitl_review_prototype:
    description: |
      Create the HITL review prototype with standardized review UI.
      
      This prototype:
      1. Loads all 4 otter GLB variants
      2. Renders them in the biome diorama scene
      3. Provides HITL review controls UNDER the canvas
      
      HITL Review UI (standardized for ALL prototypes):
      - Material-UI Slider (1-10 rating)
      - Text area for notes
      - REJECT button (red, destructive)
      - SAVE button (green, primary)
      - Always positioned UNDER the R3F canvas
      
      This UI component should be REUSABLE for future prototypes.
    expected_output: |
      ## HITL Review Prototype
      
      ### Components Created
      - client/src/prototypes/meshy_glb_validation/App.tsx
      - client/src/components/HITLReviewControls.tsx (REUSABLE)
      - client/src/prototypes/meshy_glb_validation/OtterVariants.tsx
      
      ### HITL Review Controls (Standardized)
      ```tsx
      interface HITLReviewData {
        rating: number;  // 1-10
        notes: string;
        decision: 'REJECT' | 'SAVE' | null;
      }
      ```
      
      ### Prototype Layout
      ```
      ┌─────────────────────────────┐
      │   R3F Canvas (Diorama)      │
      │   - 4 otter variants        │
      │   - Biome scene             │
      │   - Camera controls         │
      └─────────────────────────────┘
      ┌─────────────────────────────┐
      │   HITL Review Controls      │
      │   [Slider 1────────────10]  │
      │   [Notes text area______]   │
      │   [REJECT]  [SAVE]          │
      └─────────────────────────────┘
      ```
      
      ### Validation
      - All 4 GLBs load: YES
      - Animations play: YES
      - Review UI functional: YES
      - Data persists on SAVE: YES
      
      ### Ready for HITL Review
      - YES - awaiting owner review
    agent: rendering_engineer
    context: [implement_meshy_glb_pipeline]
    human_input: true  # OWNER MUST REVIEW AND APPROVE

  # -------------------------------------------------------------------------
  # OMEGA: Documentation & Context Recording
  # -------------------------------------------------------------------------
  omega_record_progress:
    description: |
      OMEGA TASK: Record all decisions, progress, and learnings into ConPort.
      
      Actions:
      1. Summarize all completed work
      2. Document architectural decisions made
      3. Record patterns discovered
      4. Update ConPort with current state
      5. Create handoff notes for next phase
      
      This runs AFTER every major phase completion.
    expected_output: |
      ## ConPort Update
      
      ### Work Completed
      - Phase 1: [summary]
      - Phase 2: [summary]
      - Phase 3: [summary]
      
      ### Architectural Decisions
      - Decision 1: [what, why, alternatives considered]
      - Decision 2: [what, why, alternatives considered]
      
      ### Patterns Discovered
      - Pattern 1: [description, when to use]
      - Pattern 2: [description, when to use]
      
      ### Current State
      - ECS schemas: [status]
      - Prototypes: [list with status]
      - Technical debt: [list]
      
      ### Handoff Notes for Next Phase
      - Prerequisites: [checklist]
      - Context to review: [files]
      - Open questions: [list]
      
      ### ConPort Updated
      - YES/NO with timestamp
    agent: technical_writer
    context: [assess_progress_and_plan_next]
